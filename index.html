<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>Note Link mini</title>
  <link rel="stylesheet" href="./note-link-ui.css?v=0.6.9-fix16">
</head>
<body>
  <header class="topbar">
    <div class="brand">Note Link v0.6.9-fix16 / No.13</div>
    <div class="spacer"></div>
    <button id="btn-undo" data-tip="一つ戻す">undo</button>
    <button id="btn-redo" data-tip="やり直す">redo</button>
    <button id="btn-print" data-tip="印刷">印刷</button>
    <button id="btn-png" data-tip="PNG保存">PNG</button>
    <button id="btn-share" data-tip="共有">共有</button>
    <span class="build-tag">build: fix16</span>
  </header>

  <div id="wrap">
    <!-- サイドツールバー -->
    <aside id="sidebar" class="sidebar" data-collapsed="0" aria-label="ツールバー">
      <!-- △/▽：中抜き三角。collapsed時はCSSで180°回転＝▽ -->
      <button class="tool" id="btn-collapse" data-tip="折りたたみ（△/▽）" aria-label="折りたたみ">
        <svg viewBox="0 0 24 24" class="chev" aria-hidden="true">
          <path d="M12 6 L5 18 L19 18 Z" fill="none" stroke="currentColor" stroke-width="2"/>
        </svg>
      </button>

      <button class="tool" data-tool="pen" id="tool-pen" data-tip="ペン">
        <svg viewBox="0 0 24 24"><path d="M4 20l5-1 9-9-4-4-9 9-1 5z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool" data-tool="marker" id="tool-marker" data-tip="マーカー">
        <svg viewBox="0 0 24 24"><path d="M3 21l6-2 10-10-4-4-10 10-2 6z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool" data-tool="eraser" id="tool-eraser" data-tip="消しゴム">
        <svg viewBox="0 0 24 24"><path d="M3 15l6 6h6l6-6-9-9-9 9z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool" data-tool="text" id="tool-text" data-tip="テキスト">
        <!-- くっきりした “T”（縦棒+横棒） -->
        <svg viewBox="0 0 24 24"><path d="M4 6H20M12 6V18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
      </button>

      <button class="tool gear" id="tool-gear" data-tip="ツール設定（表示/非表示）" aria-label="設定">
        <!-- 白いギア -->
        <svg viewBox="0 0 24 24"><path d="M12 8a4 4 0 100 8 4 4 0 000-8zm8 4h2M2 12h2M12 2v2M12 20v2m7.07-14.14l1.41-1.41M3.52 19.79l1.41-1.41M4.93 4.93L3.52 3.52M19.79 20.48l-1.41-1.41" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round"/></svg>
      </button>
    </aside>

    <!-- キャンバス -->
    <div id="stage">
      <canvas id="canvas"></canvas>
      <canvas id="overlay" aria-hidden="true"></canvas>
    </div>
  </div>

  <!-- 設定パネル（ドラッグ可） -->
  <section id="panel" class="panel" hidden>
    <h4 id="panel-title">設定</h4>
    <div class="panel-body">
      <!-- ペン -->
      <div class="panel-group" data-for="pen">
        <div class="row"><label>色</label><input id="pen-color" type="color" value="#e6fff1"></div>
        <div class="row"><label>太さ <span id="pen-w-v">4px</span></label><input id="pen-w" type="range" min="1" max="32" value="4"></div>
        <div class="row"><label>不透明度 <span id="pen-a-v">100%</span></label><input id="pen-a" type="range" min="10" max="100" value="100"></div>
        <div class="row hint">Shiftで直線（15°刻み）</div>
      </div>

      <!-- マーカー -->
      <div class="panel-group" data-for="marker">
        <div class="row"><label>色</label><input id="mk-color" type="color" value="#b9d66e"></div>
        <div class="row"><label>太さ <span id="mk-w-v">16px</span></label><input id="mk-w" type="range" min="4" max="72" value="16"></div>
        <div class="row"><label>不透明度 <span id="mk-a-v">40%</span></label><input id="mk-a" type="range" min="10" max="90" value="40"></div>
        <div class="row"><label>端の形</label>
          <select id="mk-cap">
            <option value="butt">□ 角</option>
            <option value="round">● 丸</option>
          </select>
        </div>
        <div class="row hint">Shiftで直線（15°刻み）</div>
      </div>

      <!-- 消しゴム -->
      <div class="panel-group" data-for="eraser">
        <div class="row"><label>消し幅 <span id="er-w-v">24px</span></label><input id="er-w" type="range" min="6" max="64" value="24"></div>
        <div class="row"><label>消し方</label>
          <select id="er-mode">
            <option value="rub">こする</option>
            <option value="stroke">一筆削除</option>
          </select>
        </div>
        <div class="row">
          <label>全消去</label>
          <div class="seg">
            <label><input type="radio" name="wipe" value="draw" checked>描画</label>
            <label><input type="radio" name="wipe" value="text">テキスト</label>
            <label><input type="radio" name="wipe" value="all">全部</label>
          </div>
        </div>
        <div class="row"><button class="danger" id="btn-wipe">全消去</button></div>
      </div>

      <!-- テキスト -->
      <div class="panel-group" data-for="text">
        <div class="row"><label>文字サイズ <span id="tx-size-v">24px</span></label><input id="tx-size" type="range" min="12" max="96" value="24"></div>
        <div class="row"><label>色</label><input id="tx-color" type="color" value="#ffffff"></div>
        <div class="row seg">
          <label><input id="tx-bold" type="checkbox">太字</label>
          <label><input id="tx-italic" type="checkbox">斜体</label>
        </div>
        <div class="row">
          <button id="btn-add-text">テキストを追加</button>
          <button id="btn-del-text" class="danger">選択テキスト削除</button>
        </div>
        <div class="hint">テキスト枠はドラッグで移動。空の枠は自動削除。</div>
      </div>

      <!-- 共通（グリッド） -->
      <div class="panel-group" data-for="global" style="border-top:1px solid rgba(255,255,255,.12); padding-top:8px; margin-top:6px;">
        <div class="row"><label>グリッド</label>
          <label><input type="checkbox" id="grid-on">表示</label>
          <select id="grid-mm">
            <option value="5">5mm</option>
            <option value="10">10mm</option>
          </select>
          <input type="color" id="grid-col" value="#2a3a66">
        </div>
      </div>
    </div>
    <button class="close" id="panel-close">閉じる</button>
  </section>

  <script>
  /* ============== main ============== */
  const $$=(s,r=document)=>r.querySelector(s); const $$$=(s,r=document)=>[...r.querySelectorAll(s)];

  const topbarH=44, stage=$$("#stage"), canvas=$$("#canvas"), guide=$$("#overlay");
  const ctx=canvas.getContext("2d"), gtx=guide.getContext("2d");

  function fit(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const w=stage.clientWidth, h=stage.clientHeight;
    canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr);
    canvas.style.width=w+"px"; canvas.style.height=h+"px";
    guide.width=canvas.width; guide.height=canvas.height;
    guide.style.width=canvas.style.width; guide.style.height=canvas.style.height;
    ctx.setTransform(dpr,0,0,dpr,0,0); gtx.setTransform(dpr,0,0,dpr,0,0);
    redraw();
  }
  window.addEventListener("resize",fit);

  let tool="pen", drawing=false, shiftOn=false, start=null, points=[], strokes=[], texts=[], selTextId=null, nextTextOffset=0;

  /* ---- Undo/Redo（最大10段） ---- */
  const UNDO_MAX=10; let undoStack=[], redoStack=[];
  function snapshot(){ return {strokes:JSON.parse(JSON.stringify(strokes)), texts:JSON.parse(JSON.stringify(texts))}; }
  function pushUndo(){ undoStack.push(snapshot()); if(undoStack.length>UNDO_MAX) undoStack.shift(); redoStack.length=0; }
  function undo(){ if(!undoStack.length) return; redoStack.push(snapshot()); const s=undoStack.pop(); strokes=s.strokes; texts=s.texts; redraw(); }
  function redo(){ if(!redoStack.length) return; undoStack.push(snapshot()); const s=redoStack.pop(); strokes=s.strokes; texts=s.texts; redraw(); }

  /* ---- 角度スナップ＆ガイド ---- */
  function snap15(a,b){ const dx=b.x-a.x, dy=b.y-a.y, len=Math.hypot(dx,dy)||0.0001;
    let ang=Math.atan2(dy,dx), stp=Math.PI/12; ang=Math.round(ang/stp)*stp;
    return {x:a.x+Math.cos(ang)*len, y:a.y+Math.sin(ang)*len, deg:Math.round(ang*180/Math.PI)}; }

  function updateOverlay(current){
    gtx.clearRect(0,0,guide.width,guide.height);
    // Grid
    if($$("#grid-on").checked){
      const mm=+$$("#grid-mm").value, px=mm*(96/25.4), col=$$("#grid-col").value;
      gtx.save(); gtx.strokeStyle=col+"CC"; gtx.lineWidth=1;
      for(let x=0;x<guide.width;x+=px){ gtx.beginPath(); gtx.moveTo(x,0); gtx.lineTo(x,guide.height); gtx.stroke(); }
      for(let y=0;y<guide.height;y+=px){ gtx.beginPath(); gtx.moveTo(0,y); gtx.lineTo(guide.width,y); gtx.stroke(); }
      gtx.restore();
    }
    // Angle guide
    if(shiftOn && start && current){
      const r=56; gtx.save(); gtx.translate(start.x,start.y);
      gtx.strokeStyle="rgba(255,255,255,.35)"; gtx.lineWidth=1; gtx.setLineDash([4,4]);
      for(let i=0;i<12;i++){ const a=i*Math.PI/12; gtx.beginPath(); gtx.moveTo(0,0); gtx.lineTo(Math.cos(a)*r,Math.sin(a)*r); gtx.stroke(); }
      gtx.setLineDash([]); gtx.beginPath(); gtx.arc(0,0,r,0,Math.PI*2); gtx.stroke(); gtx.restore();
      // angle label near tip
      gtx.save(); gtx.fillStyle="rgba(255,255,255,.85)"; gtx.font="12px system-ui"; gtx.fillText(current.deg+"°", current.x+8, current.y-8); gtx.restore();
    }
  }

  function redraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(const s of strokes){
      ctx.save(); ctx.lineCap=s.cap||"round"; ctx.lineJoin="round";
      ctx.strokeStyle=s.color; ctx.globalAlpha=(s.a??100)/100; ctx.lineWidth=s.w;
      ctx.beginPath(); s.pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.stroke(); ctx.restore();
    }
    for(const t of texts){
      const font=`${t.italic?'italic ':''}${t.bold?'700 ':''}${t.size}px/1.2 system-ui,-apple-system,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif`;
      ctx.save(); ctx.font=font; ctx.fillStyle=t.color; ctx.textBaseline="top";
      const lines=t.text.split("\n");
      const w=Math.max(...lines.map(ln=>ctx.measureText(ln).width),24), h=lines.length*t.size*1.2;
      t._w=w; t._h=h; // ヒット判定用に保存
      lines.forEach((ln,i)=> ctx.fillText(ln,t.x,t.y+i*t.size*1.2));
      if(t.id===selTextId){ ctx.strokeStyle="rgba(120,200,255,.9)"; ctx.setLineDash([4,4]); ctx.strokeRect(t.x-6,t.y-6,w+12,h+12); }
      ctx.restore();
    }
    updateOverlay();
  }

  function pos(e){ const r=canvas.getBoundingClientRect(); const p=e.touches?e.touches[0]:e; return {x:p.clientX-r.left, y:p.clientY-r.top}; }

  /* ---- input ---- */
  let draggingText=false, dx=0, dy=0;

  canvas.addEventListener("pointerdown",e=>{
    canvas.setPointerCapture(e.pointerId);
    const p=pos(e); start=p; drawing=true; points=[p];
    if(tool==="text"){
      // 末尾から当たり判定（上にあるもの優先）
      const hit=[...texts].reverse().find(t=> p.x>=t.x-6 && p.x<=t.x+(t._w??300)+6 && p.y>=t.y-6 && p.y<=t.y+(t._h??40)+6 );
      if(hit){ selTextId=hit.id; draggingText=true; dx=p.x-hit.x; dy=p.y-hit.y; redraw(); return; }
      selTextId=null; redraw(); return;
    }
    if(shiftOn) updateOverlay({x:p.x,y:p.y,deg:0});
  });

  canvas.addEventListener("pointermove",e=>{
    if(!drawing) return; const p=pos(e);
    if(tool==="text" && draggingText && selTextId){ const t=texts.find(t=>t.id===selTextId); if(!t) return; t.x=p.x-dx; t.y=p.y-dy; redraw(); return; }
    if(tool==="pen"||tool==="marker"){
      const q=shiftOn? snap15(start,p): p; points=[start,q]; redraw();
      // preview
      ctx.save(); ctx.lineCap=(tool==="marker")? $$("#mk-cap").value : "round"; ctx.lineJoin="round";
      ctx.strokeStyle=(tool==="marker")? $$("#mk-color").value : $$("#pen-color").value;
      ctx.globalAlpha=(tool==="marker")? (+$$("#mk-a").value/100) : (+$$("#pen-a").value/100);
      ctx.lineWidth=(tool==="marker")? (+$$("#mk-w").value) : (+$$("#pen-w").value);
      ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y); ctx.lineTo(points[1].x,points[1].y); ctx.stroke(); ctx.restore();
      if(shiftOn) updateOverlay(q);
    }else if(tool==="eraser" && $$("#er-mode").value==="rub"){
      ctx.save(); ctx.globalCompositeOperation="destination-out"; ctx.beginPath();
      ctx.arc(p.x,p.y,(+$$("#er-w").value)/2,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
  });

  function commitStroke(){
    if(tool==="pen"||tool==="marker"){
      const color=(tool==="marker")? $$("#mk-color").value : $$("#pen-color").value;
      const w=(tool==="marker")? (+$$("#mk-w").value) : (+$$("#pen-w").value);
      const a=(tool==="marker")? (+$$("#mk-a").value) : (+$$("#pen-a").value);
      const cap=(tool==="marker")? $$("#mk-cap").value : "round";
      strokes.push({type:tool, pts:[points[0], points[1]??points[0]], color, w, a, cap}); redraw();
    }
  }

  canvas.addEventListener("pointerup",e=>{
    if(tool==="text" && draggingText){ draggingText=false; drawing=false; pushUndo(); return; }
    drawing=false; commitStroke(); updateOverlay(); pushUndo();
  });
  canvas.addEventListener("pointercancel",()=>{ drawing=false; draggingText=false; updateOverlay(); });

  // 一筆削除（クリックで近傍の線を消す）
  canvas.addEventListener("click",e=>{
    if(tool!=="eraser"||$$("#er-mode").value!=="stroke") return; const p=pos(e);
    const w=+$$("#er-w").value;
    const idx=strokes.findIndex(s=>{
      const xs=s.pts.map(p=>p.x), ys=s.pts.map(p=>p.y);
      const minx=Math.min(...xs)-w, maxx=Math.max(...xs)+w, miny=Math.min(...ys)-w, maxy=Math.max(...ys)+w;
      return p.x>=minx&&p.x<=maxx&&p.y>=miny&&p.y<=maxy;
    });
    if(idx>=0){ strokes.splice(idx,1); redraw(); pushUndo(); }
  });

  // キー
  window.addEventListener("keydown",e=>{
    if(e.key==="Shift"){ shiftOn=true; if(start) updateOverlay({x:start.x,y:start.y,deg:0}); }
    if((e.key==="Delete"||e.key==="Backspace") && tool==="text" && selTextId){ texts=texts.filter(t=>t.id!==selTextId); selTextId=null; redraw(); pushUndo(); }
    if(e.ctrlKey && e.key.toLowerCase()==="z"){ e.preventDefault(); undo(); }
    if((e.ctrlKey && e.key.toLowerCase()==="y") || (e.ctrlKey && e.shiftKey && e.key.toLowerCase()==="z")){ e.preventDefault(); redo(); }
  });
  window.addEventListener("keyup",e=>{ if(e.key==="Shift"){ shiftOn=false; updateOverlay(); } });

  // テキスト
  function addTextAt(x,y){
    const id=(crypto?.randomUUID?.()||Math.random().toString(36).slice(2));
    const off=(nextTextOffset%8)*32; nextTextOffset++;
    const t={id,x:Math.max(16,x-120+off),y:Math.min(canvas.height/2,(y+off)),text:"テキスト",
      size:+$$("#tx-size").value,color:$$("#tx-color").value,bold:$$("#tx-bold").checked,italic:$$("#tx-italic").checked};
    texts.push(t); selTextId=id; redraw(); pushUndo();
  }
  $$("#btn-add-text").addEventListener("click",()=>addTextAt(120,140));
  $$("#btn-del-text").addEventListener("click",()=>{ if(!selTextId) return; texts=texts.filter(t=>t.id!==selTextId); selTextId=null; redraw(); pushUndo(); });
  function applyTextStyles(){
    if(!selTextId) return; const t=texts.find(t=>t.id===selTextId); if(!t) return;
    t.size=+$$("#tx-size").value; t.color=$$("#tx-color").value; t.bold=$$("#tx-bold").checked; t.italic=$$("#tx-italic").checked; redraw(); pushUndo();
  }
  ["tx-size","tx-color","tx-bold","tx-italic"].forEach(id=>$$("#"+id)?.addEventListener("input",applyTextStyles));

  // パネル
  function panelFor(t,show){
    const p=$$("#panel");
    $$$(".panel-group",p).forEach(g=>{ g.style.display=(g.dataset.for===t||g.dataset.for==="global")?"block":"none"; });
    $$("#panel-title").textContent = t==="pen"?"ペン設定":t==="marker"?"マーカー設定":t==="eraser"?"消しゴム設定":t==="text"?"テキスト設定":"設定";
    if(show) p.removeAttribute("hidden");
  }
  function markActive(){
    $$$(".tool").forEach(b=>b.classList.toggle("active", b.dataset.tool===tool));
    $$("#tool-gear").classList.toggle("active", !$$("#panel").hasAttribute("hidden"));
  }
  $$$(".tool[data-tool]").forEach(b=>b.addEventListener("click",()=>{ tool=b.dataset.tool; selTextId=null; panelFor(tool,true); markActive(); }));
  $$("#tool-gear").addEventListener("click",()=>{ const p=$$("#panel"); if(p.hasAttribute("hidden")) panelFor(tool,true); else p.setAttribute("hidden",""); markActive(); });
  $$("#panel-close").addEventListener("click",()=>{ $$("#panel").setAttribute("hidden",""); markActive(); });

  // 値ラベル
  function bindValue(id,view,suf=""){ const i=$$("#"+id), v=$$("#"+view); if(!i||!v) return; const f=()=>v.textContent=i.value+suf; i.addEventListener("input",f); f(); }
  bindValue("pen-w","pen-w-v","px"); bindValue("pen-a","pen-a-v","%");
  bindValue("mk-w","mk-w-v","px");   bindValue("mk-a","mk-a-v","%");
  bindValue("er-w","er-w-v","px");   bindValue("tx-size","tx-size-v","px");

  // パネルをドラッグ移動
  (function(){
    const p=$$("#panel"); let drag=false,ox=0,oy=0;
    $$("#panel-title").addEventListener("pointerdown",e=>{ drag=true; p.setPointerCapture(e.pointerId); const r=p.getBoundingClientRect(); ox=e.clientX-r.left; oy=e.clientY-r.top; });
    p.addEventListener("pointermove",e=>{ if(!drag) return; p.style.left=(e.clientX-ox)+"px"; p.style.top=(e.clientY-oy)+"px"; });
    p.addEventListener("pointerup",()=>drag=false);
  })();

  // ツールバー開閉（△↔▽ はCSSで自動回転）
  $$("#btn-collapse").addEventListener("click",()=>{ const sb=$$("#sidebar"); sb.setAttribute("data-collapsed", sb.getAttribute("data-collapsed")==="1"?"0":"1"); });

  // 上部バー
  $$("#btn-undo").addEventListener("click",undo);
  $$("#btn-redo").addEventListener("click",redo);
  $$("#btn-png").addEventListener("click",()=>{ const a=document.createElement("a"); a.download="note-link.png"; a.href=canvas.toDataURL("image/png"); a.click(); });
  $$("#btn-print").addEventListener("click",()=>{ const win=window.open("","print"); win.document.write(`<img src="${canvas.toDataURL("image/png")}" style="max-width:100%">`); win.document.close(); win.focus(); win.print(); win.close(); });
  $$("#btn-share").addEventListener("click",async()=>{
    try{
      const blob=await (await fetch(canvas.toDataURL("image/png"))).blob();
      const file=new File([blob],"note.png",{type:"image/png"});
      if(navigator.share && navigator.canShare?.({files:[file]})){ await navigator.share({files:[file], title:"Note Link"}); }
      else{ const a=document.createElement("a"); a.download="note-link.png"; a.href=URL.createObjectURL(blob); a.click(); }
    }catch(e){}
  });

  function init(){ document.documentElement.style.setProperty("--topbar-h", topbarH+"px"); fit(); panelFor("pen",true); markActive(); }
  init();
  </script>
</body>
</html>
