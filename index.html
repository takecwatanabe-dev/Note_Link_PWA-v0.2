<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Note Link mini</title>
  <link rel="stylesheet" href="./note-link-ui.css?v=0.6.9-fix14">
</head>
<body>
  <header class="topbar">
    <div class="brand">Note Link v0.6.9-fix14 / No.13</div>
    <div class="spacer"></div>
    <button id="btn-undo" data-tip="一つ戻す">undo</button>
    <button id="btn-print" data-tip="印刷">印刷</button>
    <button id="btn-png" data-tip="PNG保存">PNG</button>
    <button id="btn-share" data-tip="共有">共有</button>
    <span class="build-tag">build: fix14</span>
  </header>

  <div id="wrap">
    <!-- ツールバー -->
    <aside id="sidebar" class="sidebar" data-collapsed="0" aria-label="ツールバー">
      <button class="tool" id="btn-collapse" data-tip="折りたたみ（△/▽）" aria-label="折りたたみ">
        <svg viewBox="0 0 24 24" class="chev"><path d="M4 14l8-8 8 8" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool" data-tool="pen" id="tool-pen" data-tip="ペン">
        <svg viewBox="0 0 24 24"><path d="M4 20l5-1 9-9-4-4-9 9-1 5z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool" data-tool="marker" id="tool-marker" data-tip="マーカー">
        <svg viewBox="0 0 24 24"><path d="M3 21l6-2 10-10-4-4-10 10-2 6z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool" data-tool="eraser" id="tool-eraser" data-tip="消しゴム">
        <svg viewBox="0 0 24 24"><path d="M3 15l6 6h6l6-6-9-9-9 9z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool" data-tool="text" id="tool-text" data-tip="テキスト">
        <svg viewBox="0 0 24 24"><path d="M4 6h16M12 6v12" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>

      <button class="tool gear" id="tool-gear" data-tip="ツール設定（表示/非表示）" aria-label="設定">
        <svg viewBox="0 0 24 24"><path d="M12 8a4 4 0 100 8 4 4 0 000-8zm8 4l2 0m-18 0l-2 0m9-9l0-2m0 22l0 2m8.5-16.5l1.4-1.4M4.1 19.9L2.7 21.3m0-18.6L4.1 4.1M19.9 19.9l1.4 1.4" fill="none" stroke="currentColor" stroke-width="2"/></svg>
      </button>
    </aside>

    <!-- キャンバス -->
    <div id="stage">
      <canvas id="canvas"></canvas>
      <canvas id="overlay" aria-hidden="true"></canvas> <!-- 角度ガイドなど一時描画 -->
    </div>
  </div>

  <!-- 設定パネル（ドラッグ移動可能） -->
  <section id="panel" class="panel" hidden>
    <h4 id="panel-title">設定</h4>
    <div class="panel-body">
      <!-- ペン -->
      <div class="panel-group" data-for="pen">
        <div class="row"><label>色</label><input id="pen-color" type="color" value="#e6fff1"></div>
        <div class="row"><label>太さ <span id="pen-w-v">4px</span></label><input id="pen-w" type="range" min="1" max="32" value="4"></div>
        <div class="row"><label>不透明度 <span id="pen-a-v">100%</span></label><input id="pen-a" type="range" min="10" max="100" value="100"></div>
        <div class="row hint">Shiftで直線（15°刻み）</div>
      </div>

      <!-- マーカー -->
      <div class="panel-group" data-for="marker">
        <div class="row"><label>色</label><input id="mk-color" type="color" value="#b9d66e"></div>
        <div class="row"><label>太さ <span id="mk-w-v">16px</span></label><input id="mk-w" type="range" min="4" max="72" value="16"></div>
        <div class="row"><label>不透明度 <span id="mk-a-v">40%</span></label><input id="mk-a" type="range" min="10" max="90" value="40"></div>
        <div class="row"><label>端の形</label>
          <select id="mk-cap">
            <option value="round">● 丸（現行）</option>
            <option value="butt">□ 角</option>
          </select>
        </div>
        <div class="row hint">Shiftで直線（15°刻み）</div>
      </div>

      <!-- 消しゴム -->
      <div class="panel-group" data-for="eraser">
        <div class="row"><label>消し幅 <span id="er-w-v">24px</span></label><input id="er-w" type="range" min="6" max="64" value="24"></div>
        <div class="row"><label>消し方</label>
          <select id="er-mode">
            <option value="rub">こする</option>
            <option value="stroke">一筆削除</option>
          </select>
        </div>
        <div class="row">
          <label>全消去</label>
          <div class="seg">
            <label><input type="radio" name="wipe" value="draw" checked>描画</label>
            <label><input type="radio" name="wipe" value="text">テキスト</label>
            <label><input type="radio" name="wipe" value="all">全部</label>
          </div>
        </div>
        <div class="row"><button class="danger" id="btn-wipe">全消去</button></div>
      </div>

      <!-- テキスト -->
      <div class="panel-group" data-for="text">
        <div class="row"><label>文字サイズ <span id="tx-size-v">24px</span></label><input id="tx-size" type="range" min="12" max="96" value="24"></div>
        <div class="row"><label>色</label><input id="tx-color" type="color" value="#ffffff"></div>
        <div class="row seg">
          <label><input id="tx-bold" type="checkbox">太字</label>
          <label><input id="tx-italic" type="checkbox">斜体</label>
        </div>
        <div class="row">
          <button id="btn-add-text">テキストを追加</button>
          <button id="btn-del-text" class="danger">選択テキスト削除</button>
        </div>
        <div class="hint">テキストを選択してサイズ/色/太字/斜体を変更。選択部分だけのサイズ変更も可。</div>
      </div>
    </div>
    <button class="close" id="panel-close">閉じる</button>
  </section>

  <script>
  /* =========================
     v0.6.9-fix14  メインスクリプト
     ========================= */
  const $$ = (sel, root=document) => root.querySelector(sel);
  const $$$ = (sel, root=document) => [...root.querySelectorAll(sel)];

  // ---- レイアウト定数 ----
  const topbarH = 44; // CSSと厳密同期
  const stage = $$("#stage");
  const canvas = $$("#canvas");
  const guide = $$("#overlay");
  const ctx = canvas.getContext("2d");
  const gtx = guide.getContext("2d");

  // リサイズ
  function fit() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = stage.clientWidth;
    const h = stage.clientHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    guide.width = canvas.width;
    guide.height = canvas.height;
    guide.style.width = canvas.style.width;
    guide.style.height = canvas.style.height;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    gtx.setTransform(dpr,0,0,dpr,0,0);
    redraw();
  }
  window.addEventListener("resize", fit);

  // ---- 状態 ----
  let tool = "pen";
  let drawing = false;
  let shiftOn = false;
  let start = null;
  let points = [];
  let strokes = [];   // {type:'pen'|'marker', pts:[{x,y}], color, w, a, cap}
  let texts = [];     // {id,x,y,text,size,color,bold,italic,sel:[start,end]}
  let selTextId = null;
  let undoStack = [];

  // ---- ツールバー選択表示 ----
  function markActive() {
    $$$(".tool").forEach(b => b.classList.toggle("active", b.dataset.tool === tool));
    // 設定ボタンのラインは「パネル表示中」にのみ点灯
    const panelOpen = !$$("#panel").hasAttribute("hidden");
    $$("#tool-gear").classList.toggle("active", panelOpen);
  }

  // ---- Undo ----
  function pushUndo() {
    undoStack.push({
      strokes: JSON.parse(JSON.stringify(strokes)),
      texts: JSON.parse(JSON.stringify(texts)),
      img: ctx.getImageData(0,0,canvas.width,canvas.height)
    });
    if (undoStack.length > 20) undoStack.shift();
  }
  function undo() {
    const last = undoStack.pop();
    if (!last) return;
    strokes = last.strokes;
    texts = last.texts;
    ctx.putImageData(last.img, 0, 0);
    redraw(); // 安全のため
  }

  // ---- 角度スナップ（15°）と蛇行防止 ----
  function snap15(from, to) {
    const dx = to.x - from.x, dy = to.y - from.y;
    const len = Math.hypot(dx, dy);
    if (len < 2) return {x: to.x, y: to.y};
    let ang = Math.atan2(dy, dx);
    const step = Math.PI / 12; // 15°
    ang = Math.round(ang / step) * step;
    return { x: from.x + Math.cos(ang) * len, y: from.y + Math.sin(ang) * len };
  }
  function showGuide(p) {
    gtx.clearRect(0,0,guide.width,guide.height);
    const r = 56;
    gtx.save();
    gtx.translate(p.x, p.y);
    gtx.strokeStyle = "rgba(255,255,255,.35)";
    gtx.lineWidth = 1;
    gtx.setLineDash([4,4]);
    for (let i=0;i<12;i++) {
      const a = i*Math.PI/12;
      gtx.beginPath();
      gtx.moveTo(0,0);
      gtx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
      gtx.stroke();
    }
    gtx.setLineDash([]);
    gtx.beginPath(); gtx.arc(0,0, r, 0, Math.PI*2); gtx.stroke();
    gtx.restore();
  }
  function hideGuide(){ gtx.clearRect(0,0,guide.width,guide.height); }

  // ---- キャンバス描画 ----
  function redraw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // strokes
    for (const s of strokes) {
      ctx.save();
      ctx.lineCap = s.cap || "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = s.color;
      ctx.globalAlpha = (s.a ?? 100) / 100;
      ctx.lineWidth = s.w;
      ctx.beginPath();
      s.pts.forEach((p,i)=>{
        if (i===0) ctx.moveTo(p.x,p.y);
        else ctx.lineTo(p.x,p.y);
      });
      ctx.stroke();
      ctx.restore();
    }
    // texts
    for (const t of texts) {
      const font = `${t.italic?'italic ':''}${t.bold?'700 ':''}${t.size}px/1.2 system-ui, -apple-system, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif`;
      ctx.save();
      ctx.font = font;
      ctx.fillStyle = t.color;
      ctx.textBaseline = "top";
      const lines = t.text.split("\n");
      lines.forEach((ln,i)=> ctx.fillText(ln, t.x, t.y + i*t.size*1.2));
      // 枠の選択可視化
      if (t.id === selTextId) {
        const w = Math.max(...lines.map(ln=>ctx.measureText(ln).width), 24);
        const h = lines.length * t.size * 1.2;
        ctx.strokeStyle="rgba(120,200,255,.9)";
        ctx.setLineDash([4,4]);
        ctx.strokeRect(t.x-6, t.y-6, w+12, h+12);
      }
      ctx.restore();
    }
  }

  function pos(e){
    const r = canvas.getBoundingClientRect();
    if (e.touches && e.touches[0]) e = e.touches[0];
    return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
  }

  // ---- 入力ハンドラ ----
  canvas.addEventListener("pointerdown", (e)=>{
    canvas.setPointerCapture(e.pointerId);
    pushUndo();
    drawing = true;
    start = pos(e);
    points = [start];
    if (shiftOn) showGuide(start);
    if (tool === "text") {
      // テキスト追加 or 選択
      const t = texts.findLast(t => (start.x>=t.x && start.x<=t.x+800 && start.y>=t.y && start.y<=t.y+ t.size*1.2*3));
      if (t) { selTextId = t.id; redraw(); }
    }
  });
  canvas.addEventListener("pointermove", (e)=>{
    if (!drawing) return;
    const p = pos(e);
    if (tool==="pen" || tool==="marker") {
      let q = p;
      if (shiftOn) q = snap15(start, p); // 蛇行防止：必ずスナップ先だけに更新
      points = [start, q];
      redraw();
      // 進行線のプレビュー
      ctx.save();
      ctx.lineCap = (tool==="marker") ? ($$("#mk-cap").value) : "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = (tool==="marker") ? $$("#mk-color").value : $$("#pen-color").value;
      ctx.globalAlpha = (tool==="marker") ? ($$("#mk-a").value/100) : ($$("#pen-a").value/100);
      ctx.lineWidth = (tool==="marker") ? (+$$("#mk-w").value) : (+$$("#pen-w").value);
      ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); ctx.lineTo(points[1].x, points[1].y); ctx.stroke();
      ctx.restore();
    } else if (tool==="eraser" && $$("#er-mode").value==="rub") {
      // ラバーで消す
      ctx.save();
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(p.x, p.y, (+$$("#er-w").value)/2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  });
  function commitStroke() {
    if (tool==="pen" || tool==="marker") {
      const color = (tool==="marker") ? $$("#mk-color").value : $$("#pen-color").value;
      const w = (tool==="marker") ? (+$$("#mk-w").value) : (+$$("#pen-w").value);
      const a = (tool==="marker") ? (+$$("#mk-a").value) : (+$$("#pen-a").value);
      const cap = (tool==="marker") ? $$("#mk-cap").value : "round";
      const s = {type:tool, pts:[points[0], points[1]??points[0]], color, w, a, cap};
      strokes.push(s);
      hideGuide();
      redraw();
    }
  }
  canvas.addEventListener("pointerup", ()=>{
    if (!drawing) return;
    drawing = false;
    commitStroke();
  });
  canvas.addEventListener("pointercancel", ()=>{ drawing=false; hideGuide(); });

  // Shift 全域監視
  window.addEventListener("keydown", e=>{ if (e.key==="Shift") { shiftOn=true; if (start) showGuide(start);} });
  window.addEventListener("keyup",   e=>{ if (e.key==="Shift") { shiftOn=false; hideGuide(); } });

  // ---- テキスト追加・編集・削除 ----
  function addTextAt(x,y){
    const id = crypto.randomUUID();
    const t = {
      id, x, y,
      text: "テキスト",
      size: +$$("#tx-size").value,
      color: $$("#tx-color").value,
      bold: $$("#tx-bold").checked,
      italic: $$("#tx-italic").checked
    };
    texts.push(t); selTextId = id; redraw();
  }
  $$("#btn-add-text").addEventListener("click", ()=>{
    addTextAt(120, 120);
  });
  $$("#btn-del-text").addEventListener("click", ()=>{
    if (!selTextId) return;
    texts = texts.filter(t=>t.id !== selTextId);
    selTextId = null; redraw();
  });

  // 右クリックでテキスト選択
  canvas.addEventListener("contextmenu", e=>{
    const p = pos(e); e.preventDefault();
    const t = texts.findLast(t => (p.x>=t.x && p.x<=t.x+800 && p.y>=t.y && p.y<=t.y+ t.size*1.2*3));
    if (t) { selTextId = t.id; redraw(); }
  });

  // テキストスタイル反映（選択中へ）
  function applyTextStyles(){
    if (!selTextId) return;
    const t = texts.find(t=>t.id===selTextId); if (!t) return;
    t.size = +$$("#tx-size").value;
    t.color = $$("#tx-color").value;
    t.bold = $$("#tx-bold").checked;
    t.italic = $$("#tx-italic").checked;
    redraw();
  }
  ["tx-size","tx-color","tx-bold","tx-italic"].forEach(id=>{
    $$("#"+id).addEventListener("input", applyTextStyles);
  });

  // ---- 消しゴム：一筆削除・全消去 ----
  canvas.addEventListener("click", (e)=>{
    if (tool!=="eraser" || $$("#er-mode").value!=="stroke") return;
    const p = pos(e);
    // 一番近い線をざっくり削除
    const idx = strokes.findIndex(s=>{
      const bb = s.pts.reduce((b,q)=>({
        minx:Math.min(b.minx,q.x), miny:Math.min(b.miny,q.y),
        maxx:Math.max(b.maxx,q.x), maxy:Math.max(b.maxy,q.y)
      }), {minx:1e9, miny:1e9, maxx:-1e9, maxy:-1e9});
      const m = +$$("#er-w").value;
      return (p.x>=bb.minx-m && p.x<=bb.maxx+m && p.y>=bb.miny-m && p.y<=bb.maxy+m);
    });
    if (idx>=0) { pushUndo(); strokes.splice(idx,1); redraw(); }
  });

  $$("#btn-wipe").addEventListener("click", ()=>{
    const val = $$$("input[name='wipe']").find(r=>r.checked).value;
    pushUndo();
    if (val==="draw")       { strokes=[]; redraw(); }
    else if (val==="text")  { texts=[]; redraw(); }
    else                    { strokes=[]; texts=[]; redraw(); }
  });

  // ---- ツール切替 & 設定表示 ----
  $$$(".tool[data-tool]").forEach(b=>{
    b.addEventListener("click", ()=>{
      tool = b.dataset.tool;
      selTextId = null;
      panelFor(tool, true);
      markActive();
    });
  });

  // 設定パネルの切替
  function panelFor(t, show){
    const p = $$("#panel");
    $$$(".panel-group", p).forEach(g=>{
      g.style.display = (g.dataset.for===t) ? "block" : "none";
    });
    $$("#panel-title").textContent =
      t==="pen" ? "ペン設定" :
      t==="marker" ? "マーカー設定" :
      t==="eraser" ? "消しゴム設定" :
      t==="text" ? "テキスト設定" : "設定";
    if (show) p.removeAttribute("hidden");
  }
  $$("#tool-gear").addEventListener("click", ()=>{
    const p = $$("#panel");
    if (p.hasAttribute("hidden")) panelFor(tool, true);
    else p.setAttribute("hidden","");
    markActive();
  });
  $$("#panel-close").addEventListener("click", ()=>{
    $$("#panel").setAttribute("hidden",""); markActive();
  });

  // 設定値ラベル更新
  function bindValue(id, view, suffix=""){
    const inp = $$("#"+id), v = $$("#"+view);
    if (!inp || !v) return;
    const fn = ()=> v.textContent = inp.value + suffix;
    inp.addEventListener("input", fn); fn();
  }
  bindValue("pen-w","pen-w-v","px");
  bindValue("pen-a","pen-a-v","%");
  bindValue("mk-w","mk-w-v","px");
  bindValue("mk-a","mk-a-v","%");
  bindValue("er-w","er-w-v","px");
  bindValue("tx-size","tx-size-v","px");

  // ツールバーの開閉
  $$("#btn-collapse").addEventListener("click", ()=>{
    const sb = $$("#sidebar");
    const collapsed = sb.getAttribute("data-collapsed")==="1";
    sb.setAttribute("data-collapsed", collapsed ? "0" : "1");
  });

  // 設定パネル ドラッグ移動
  (function makePanelDraggable(){
    const p = $$("#panel");
    let drag=false, ox=0, oy=0;
    $$("#panel-title").addEventListener("pointerdown", (e)=>{
      drag=true; p.setPointerCapture(e.pointerId);
      const r = p.getBoundingClientRect();
      ox = e.clientX - r.left; oy = e.clientY - r.top;
    });
    p.addEventListener("pointermove", (e)=>{
      if (!drag) return;
      p.style.left = (e.clientX - ox) + "px";
      p.style.top  = (e.clientY - oy) + "px";
    });
    p.addEventListener("pointerup", ()=> drag=false);
  })();

  // 上部バーのボタン
  $$("#btn-undo").addEventListener("click", undo);
  $$("#btn-png").addEventListener("click", ()=>{
    const a = document.createElement("a");
    a.download = "note-link.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  });
  $$("#btn-print").addEventListener("click", ()=>{
    const win = window.open("","print");
    win.document.write(`<img src="${canvas.toDataURL("image/png")}" style="max-width:100%">`);
    win.document.close(); win.focus(); win.print(); win.close();
  });
  $$("#btn-share").addEventListener("click", async ()=>{
    try {
      const blob = await (await fetch(canvas.toDataURL("image/png"))).blob();
      if (navigator.share && navigator.canShare?.({ files:[new File([blob],"note.png",{type:"image/png"})]})) {
        await navigator.share({ files:[new File([blob],"note.png",{type:"image/png"})], title:"Note Link" });
      } else {
        const a = document.createElement("a");
        a.download = "note-link.png"; a.href = URL.createObjectURL(blob); a.click();
      }
    } catch(e){}
  });

  // 初期セット
  function init() {
    // 上部バー高さと同期して余白ゼロに（ぴったり配置）
    document.documentElement.style.setProperty("--topbar-h", topbarH + "px");
    fit(); markActive(); panelFor("pen", true);
  }
  init();
  </script>
</body>
</html>
